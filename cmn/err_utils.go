// Package cmn provides common low-level types and utilities for all aistore projects
/*
 * Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.
 */
package cmn

import (
	"errors"
	"fmt"
	"io"
	"syscall"
)

var ErrSkip = errors.New("skip")

///////////////////////////////////////////
// common error helpers and constructors //
///////////////////////////////////////////

func PathWalkErr(err error) error {
	if IsErrObjNought(err) {
		return nil
	}
	return fmt.Errorf("filepath-walk invoked with err: %v", err)
}

// as of 1.9 net/http does not appear to provide any better way..
func IsErrConnectionRefused(err error) (yes bool) {
	return errors.Is(err, syscall.ECONNREFUSED)
}

// TCP RST
func IsErrConnectionReset(err error) (yes bool) {
	return errors.Is(err, syscall.ECONNRESET) || IsErrBrokenPipe(err)
}

// Check if a given error is a broken-pipe one.
func IsErrBrokenPipe(err error) bool {
	return errors.Is(err, syscall.EPIPE)
}

// Checks if the error is generated by any IO operation and if the error
// is severe enough to run the FSHC for mountpath testing
//
// For mountpath definition, see fs/mountfs.go
func IsIOError(err error) bool {
	if err == nil {
		return false
	}

	ioErrs := []error{
		io.ErrShortWrite,

		syscall.EIO,     // I/O error
		syscall.ENOTDIR, // mountpath is missing
		syscall.EBUSY,   // device or resource is busy
		syscall.ENXIO,   // No such device
		syscall.EBADF,   // Bad file number
		syscall.ENODEV,  // No such device
		syscall.EUCLEAN, // (mkdir)structure needs cleaning = broken filesystem
		syscall.EROFS,   // readonly filesystem
		syscall.EDQUOT,  // quota exceeded
		syscall.ESTALE,  // stale file handle
		syscall.ENOSPC,  // no space left
	}
	for _, ioErr := range ioErrs {
		if errors.Is(err, ioErr) {
			return true
		}
	}
	return false
}

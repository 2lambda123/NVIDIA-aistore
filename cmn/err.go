// Package cmn provides common low-level types and utilities for all aistore projects
/*
 * Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.
 */
package cmn

import (
	"errors"
	"fmt"
	"io"
	"os"
	"syscall"
)

var (
	ErrSkip = errors.New("skip")
)

func PathWalkErr(err error) error {
	if os.IsNotExist(err) {
		return nil
	}
	return fmt.Errorf("filepath-walk invoked with err: %v", err)
}

// as of 1.9 net/http does not appear to provide any better way..
func IsErrConnectionRefused(err error) (yes bool) {
	return errors.Is(err, syscall.ECONNREFUSED)
}

// TCP RST
func IsErrConnectionReset(err error) (yes bool) {
	return errors.Is(err, syscall.ECONNRESET) || IsErrBrokenPipe(err)
}

// Check if a given error is a broken-pipe one.
func IsErrBrokenPipe(err error) bool {
	return errors.Is(err, syscall.EPIPE)
}

// Checks if the error is generated by any IO operation and if the error
// is severe enough to run the FSHC for mountpath testing
//
// For mountpath definition, see fs/mountfs.go
func IsIOError(err error) bool {
	if err == nil {
		return false
	}

	ioErrs := []error{
		io.ErrShortWrite,

		syscall.EIO,     // I/O error
		syscall.ENOTDIR, // mountpath is missing
		syscall.EBUSY,   // device or resource is busy
		syscall.ENXIO,   // No such device
		syscall.EBADF,   // Bad file number
		syscall.ENODEV,  // No such device
		syscall.EUCLEAN, // (mkdir)structure needs cleaning = broken filesystem
		syscall.EROFS,   // readonly filesystem
		syscall.EDQUOT,  // quota exceeded
		syscall.ESTALE,  // stale file handle
		syscall.ENOSPC,  // no space left
	}
	for _, ioErr := range ioErrs {
		if errors.Is(err, ioErr) {
			return true
		}
	}
	return false
}

//===========================================================================
//
// Common errors reusable in API or client
//
//===========================================================================

type InvalidCksumError struct {
	ExpectedHash string
	ActualHash   string
}

func (e InvalidCksumError) Error() string {
	return fmt.Sprintf("Expected Hash: [%s] Actual Hash: [%s]", e.ExpectedHash, e.ActualHash)
}

func NewInvalidCksumError(eHash string, aHash string) InvalidCksumError {
	return InvalidCksumError{
		ActualHash:   aHash,
		ExpectedHash: eHash,
	}
}

type (
	NoMountpathError struct {
		mpath string
	}

	InvalidMountpathError struct {
		mpath string
		cause string
	}
)

func (e NoMountpathError) Error() string {
	return "mountpath [" + e.mpath + "] doesn't exist"
}

func NewNoMountpathError(mpath string) NoMountpathError { return NoMountpathError{mpath} }

func (e InvalidMountpathError) Error() string {
	return "invalid mountpath [" + e.mpath + "]; " + e.cause
}

func NewInvalidaMountpathError(mpath, cause string) InvalidMountpathError {
	return InvalidMountpathError{
		mpath: mpath,
		cause: cause,
	}
}

type (
	XactionNotFoundError struct {
		cause string
	}
)

func NewXactionNotFoundError(cause string) XactionNotFoundError {
	return XactionNotFoundError{cause: cause}
}

func (e XactionNotFoundError) Error() string {
	return "xaction '" + e.cause + "' not found"
}
